/*
 * Copyright (c) 2020, RTE (http://www.rte-france.com)
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/.
 */
package com.farao_community.farao.search_tree_rao.search_tree.parameters;

import com.farao_community.farao.commons.FaraoException;
import com.farao_community.farao.search_tree_rao.castor.parameters.SearchTreeRaoParameters;

import javax.annotation.Nullable;
import java.util.*;

/**
 * This class contains internal FARAO parameters used in the SearchTree algorithm.
 * These parameters are dynamically generated by the SearchTreeRaoProvider depending on the context and on
 * the user's RAO parameters, and then used in SearchTree algorithm.
 * They should not be visible to the user.
 *
 * @author Peter Mitri {@literal <peter.mitri at rte-france.com>}
 */
public final class TreeParameters {

    public enum StopCriterion {
        MIN_OBJECTIVE,
        AT_TARGET_OBJECTIVE_VALUE
    }

    private StopCriterion stopCriterion;
    private double targetObjectiveValue;

    private int maximumSearchDepth;
    private double relativeNetworkActionMinimumImpactThreshold;
    private double absoluteNetworkActionMinimumImpactThreshold;
    private int leavesInParallel;
    private boolean skipNetworkActionsFarFromMostLimitingElement;
    private int maxRa;
    private int maxTso;
    private Map<String, Integer> maxTopoPerTso;
    private Map<String, Integer> maxPstPerTso;
    private Map<String, Integer> maxRaPerTso;

    private TreeParameters() {
    }

    private TreeParameters(SearchTreeRaoParameters searchTreeRaoParameters, StopCriterion stopCriterion, double targetObjectiveValue, int maxRa, int maxTso,
                           Map<String, Integer> maxTopoPerTso, Map<String, Integer> maxPstPerTso, Map<String, Integer> maxRaPerTso, int leavesInParallel) {
        this.maximumSearchDepth = searchTreeRaoParameters.getMaximumSearchDepth();
        this.relativeNetworkActionMinimumImpactThreshold = searchTreeRaoParameters.getRelativeNetworkActionMinimumImpactThreshold();
        this.absoluteNetworkActionMinimumImpactThreshold = searchTreeRaoParameters.getAbsoluteNetworkActionMinimumImpactThreshold();
        this.skipNetworkActionsFarFromMostLimitingElement = searchTreeRaoParameters.getSkipNetworkActionsFarFromMostLimitingElement();
        this.leavesInParallel = leavesInParallel;
        this.stopCriterion = stopCriterion;
        this.targetObjectiveValue = targetObjectiveValue;
        this.maxRa = maxRa;
        this.maxTso = maxTso;
        this.maxTopoPerTso = maxTopoPerTso;
        this.maxPstPerTso = maxPstPerTso;
        this.maxRaPerTso = maxRaPerTso;
    }

    private TreeParameters(SearchTreeRaoParameters searchTreeRaoParameters, StopCriterion stopCriterion, double targetObjectiveValue, int leavesInParallel) {
        this(searchTreeRaoParameters, stopCriterion, targetObjectiveValue, Integer.MAX_VALUE, Integer.MAX_VALUE, new HashMap<>(), new HashMap<>(), new HashMap<>(), leavesInParallel);
    }

    public StopCriterion getStopCriterion() {
        return stopCriterion;
    }

    public double getTargetObjectiveValue() {
        return targetObjectiveValue;
    }

    public static TreeParameters buildForPreventivePerimeter(@Nullable SearchTreeRaoParameters searchTreeRaoParameters) {
        SearchTreeRaoParameters parameters = Objects.isNull(searchTreeRaoParameters) ? new SearchTreeRaoParameters() : searchTreeRaoParameters;

        switch (parameters.getPreventiveRaoStopCriterion()) {
            case MIN_OBJECTIVE:
                return new TreeParameters(parameters, StopCriterion.MIN_OBJECTIVE, 0.0, parameters.getPreventiveLeavesInParallel());
            case SECURE:
                return new TreeParameters(parameters, StopCriterion.AT_TARGET_OBJECTIVE_VALUE, 0.0, parameters.getPreventiveLeavesInParallel());
            default:
                throw new FaraoException("Unknown preventive RAO stop criterion: " + parameters.getPreventiveRaoStopCriterion());
        }
    }

    public static TreeParameters buildForCurativePerimeter(@Nullable SearchTreeRaoParameters searchTreeRaoParameters, Double preventiveOptimizedCost) {
        SearchTreeRaoParameters parameters = Objects.isNull(searchTreeRaoParameters) ? new SearchTreeRaoParameters() : searchTreeRaoParameters;
        StopCriterion stopCriterion;
        double targetObjectiveValue;
        switch (parameters.getCurativeRaoStopCriterion()) {
            case MIN_OBJECTIVE:
                stopCriterion = StopCriterion.MIN_OBJECTIVE;
                targetObjectiveValue = 0.0;
                break;
            case SECURE:
                stopCriterion = StopCriterion.AT_TARGET_OBJECTIVE_VALUE;
                targetObjectiveValue = 0.0;
                break;
            case PREVENTIVE_OBJECTIVE:
                stopCriterion = StopCriterion.AT_TARGET_OBJECTIVE_VALUE;
                targetObjectiveValue = preventiveOptimizedCost - parameters.getCurativeRaoMinObjImprovement();
                break;
            case PREVENTIVE_OBJECTIVE_AND_SECURE:
                stopCriterion = StopCriterion.AT_TARGET_OBJECTIVE_VALUE;
                targetObjectiveValue = Math.min(preventiveOptimizedCost - parameters.getCurativeRaoMinObjImprovement(), 0);
                break;
            default:
                throw new FaraoException("Unknown curative RAO stop criterion: " + parameters.getCurativeRaoStopCriterion());
        }
        return new TreeParameters(parameters, stopCriterion, targetObjectiveValue, parameters.getMaxCurativeRa(),
                parameters.getMaxCurativeTso(), parameters.getMaxCurativeTopoPerTso(), parameters.getMaxCurativePstPerTso(),
                parameters.getMaxCurativeRaPerTso(), parameters.getCurativeLeavesInParallel());
    }

    public int getMaximumSearchDepth() {
        return maximumSearchDepth;
    }

    public double getRelativeNetworkActionMinimumImpactThreshold() {
        return relativeNetworkActionMinimumImpactThreshold;
    }

    public double getAbsoluteNetworkActionMinimumImpactThreshold() {
        return absoluteNetworkActionMinimumImpactThreshold;
    }

    public int getLeavesInParallel() {
        return leavesInParallel;
    }

    public boolean getSkipNetworkActionsFarFromMostLimitingElement() {
        return skipNetworkActionsFarFromMostLimitingElement;
    }

    public int getMaxRa() {
        return maxRa;
    }

    public int getMaxTso() {
        return maxTso;
    }

    public Map<String, Integer> getMaxTopoPerTso() {
        return maxTopoPerTso;
    }

    public Map<String, Integer> getMaxPstPerTso() {
        return maxPstPerTso;
    }

    public Map<String, Integer> getMaxRaPerTso() {
        return maxRaPerTso;
    }
}
